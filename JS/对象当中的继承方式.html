<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 一.原型链继承
        // function Father (name, age) {
        //     this.name = name;
        //     this.age = age;
        //     this.play = [1,2,3];
        //     this.setName = function () {}
        // }
        // Father.prototype.setAge = function () {}
        // function Son (price) {
        //     this.price = price;
        //     this.setScore = function () {}
        // }
        // Son.prototype = new Father();
        // var s1 = new Son(5000);
        // var s2 = new Son(5200);

        // 原型链继承的缺点是: 无法实现多继承, 来自原型对象的所有属性被所有实例共享, 创建子类实例, 无法向父类的构造函数当中传参, 如果想为子类新增属性和方法, 必须在继承之后(Son.prototype = new Father();)执行


        // 二.借用构造函数继承
        // function Person(name, age) {
        //     this.name = name;
        //     this.age = age;
        //     this.setName = function () {}
        // }
        // function People (play) {
        //     this.play = play
        // }
        // Person.prototype.setAge = function () {}
        // function Student(name, age, price, play) {
        //     Person.call(this, name, age, play);
        //     People.call(this, play)
        //     this.price = price;
        // }
        // let s1 = new Student('jack', 20, 500,'ball');

        // 借用构造函数继承, 创建子类实例的时候可以向父类传递参数, 可以实现多继承(call多个父类对象), 缺点: 实例不是父类的实例, 只是子类的实例, 只能继承父类的实例属性和方法, 不能继承原型属性和方法, 无法实现函数复用, 影响性能

        // 三.原型链 + 借用构造函数的组合继承
        // function Person (name, age) {
        //     this.name = name;
        //     this.age = age;
        //     this.setAge = function () {}
        // }
        // Person.prototype.setAge = function () {
        //     console.log('111');
        // }
        // function Student (name, age, price) {
        //     Person.call(this,name,age);
        //     this.price = price;
        //     this.setScore = function () {}
        // }
        // Student.prototype = new Person();
        // Student.prototype.constructor = Student;
        // Student.prototype.sayHello = function () {}
        // var s1 = new Student('TOM', 20, 500);
        // var s2 = new Student('jack', 21, 222);
        
        // 原型链 + 借用构造函数的组合继承, 可以继承实例属性和方法, 也可以继承原型的属性和方法, 不存在引用属性共享问题, 可传参, 函数可复用, 缺点就是调用了两次构造函数

        // 四.组合继承的优化
        // function Person(name, age) {
        //     this.name = name;
        //     this.age = age;
        //     this.setAge = function () {}
        // }
        // Person.prototype.setAge = function () {
        //     console.log(24);
        // }
        // function Student (name, age, price) {
        //     Person.call(this, name, age);
        //     this.price = price;
        //     this.setScore = function () {}
        // }
        // Student.prototype = Person.prototype;
        // Student.prototype.sayHello = function () {}
        // var s1 = new Student('jack', 20, 500);

        // 该方法不会初始化两次实例, 但是没有办法判断实例是子类还是父类创造的

        // 五.组合继承优化2
        // function Person(name, age) {
        //     this.name = name;
        //     this.age = age;
        // }
        // Person.prototype.setAge = function () {
        //     console.log('24');
        // }
        // function Student (name, age, price) {
        //     Person.call(this, name, age);
        //     this.price = price;
        //     this.setScore = function () {}
        // }
        // Student.prototype = Object.create(Person.prototype);
        // Student.prototype.constructor = Student;
        // var s1 = new Student('jack', 20 , 500);

        // 六.class继承
        // class Person {
        //     constructor (name, age) {
        //         this.name = name;
        //         this.age = age;
        //     }
        //     ShowName() {
        //         console.log('666');
        //         console.log(this.name, this.age);
        //     }
        // }
        // let p1 = new Person('kobe', 20);
        // console.log(p1)
        // // 定义一个子类
        // class Student extends Person {
        //     constructor(name, age, salary) {
        //         super(name, age);
        //         this.salary = salary;
        //     }
        //     ShowName() {
        //         console.log('888');
        //         console.log(this.name, this.age, this.salary);
        //     }
        // }
        // let s1 = new Student('james', 20, 50000);
        // console.log(s1);

        // 并不是所有浏览器都支持class
    </script>
</body>
</html>