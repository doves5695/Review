<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // for(var i = 0; i < 5; i ++) {
        //     (function (x) {
        //         setTimeout(function () {
        //         console.log(x++);
        //     },2000)
        //     })(i)
        // }
        // console.log(i)

        // for(var i = 0; i < 3; i ++) {
        //     break
        // }
        // console.log(i) // 0
        // k = 5;
        // while(k > 1) {
        //     k--;
        //     var d = 10;
        // }
        // console.log(k) // 1
        // console.log(d) // 10


        // var a = 'apple'
        // var b = 'boy'
        // function fn() {
        //     var a = 'angel'
        //     console.log(a) // angel
        //     console.log(b) // boy
        // }
        // fn();
        // console.log(a) // apple


        // var b = 'boy';
        // console.log(b) // boy
        // function fn() {
        //     console.log(a) // undefined
        //     console.log(c) // undefined
        //     if(a === 'apple') {
        //         a = 'Alice';
        //     } else {
        //         a = 'Ada'
        //     }
        //     console.log(a)  //  Ada
        //     var a = 'Andy'
        //     middle();
        //     function middle() {
        //         console.log(c++) // NaN
        //         var c = 100;
        //         console.log(++c) // 101
        //         small();
        //         function small() {
        //             console.log(a) // andy
        //         }
        //     }
        //     var c = a = 88;
        //     function bottom () {
        //         console.log(this.b) // boy
        //         b = 'baby'
        //         console.log(b) // baby
        //     }
        //     bottom();
        // }
        // fn();
        // console.log(b); // baby

         
        // Promise的基本用法
        // 一般情况会使用new Promise来创建promise对象, 但是也可以使用promise.resolve,promis.reject这两个方法
        // Promise.resolve(11).then( (value)=> {
        //     console.log(value)
        // })
        // new Promise((resolve,reject)=> {
        //     resolve(console.log(11))
        // })

        // function testPromise (ready) {
        //    return new Promise ((resolve,reject) => {
        //         if(ready) {
        //             resolve('hello')
        //         } else {
        //             reject('NO')
        //         }
        //     })
        // }
        // testPromise(true)
        //     .then((msg) => {
        //         console.log(msg)
        //     })
        //     .catch((err) => {
        //         console.log(err)
        //     })  


        // let promise1 = new Promise((resolve, reject) => {
        //     resolve(1);
        // })
        // let promise2 = new Promise((resolve, reject) => {
        //     resolve(2);
        // })
        // let promise3 = new Promise((resolve, reject) => {
        //     resolve(3);
        // })
        // Promise.all([promise1,promise2,promise3]).then(msg => {
        //     console.log(msg)
        // })

        // let promise1 = new Promise((resolve,reject) => {
        //     reject(1)
        // })
        // let promise2 = new Promise((resolve,reject) => {
        //     resolve(2)
        // })
        // let promise3 = new Promise((resolve,reject) => {
        //     resolve(3)
        // })
        // Promise.race([promise1,promise2,promise3]).then(res => {
        //     console.log(res)
        // }).catch(rej => {
        //     console.log(rej)
        // })


        // Promise 有五种常用方法
        // 1.then
        // then后面可以接两个回调函数,第一个回调函数是当promise状态变为resolve时调用,第二个函数是当promise状态变为reject时调用,then方法是返回一个新的promise实例,因此可以链式调用
        // 2.catch
        // 在执行resolve回调函数时候, 如果出现错误, 抛出异常, 不会停止运行, 而是进入catch方法中
        // 3.all
        // all方法可以完成并行任务, 它接收一个数组, 数组的每一项都是一个promise对象.当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected
        // 4.race
        // race方法和all一样, 接受的参数是一个每项都是promise的数组但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected
        // 5.finally
        // 以上代码中, 不管promise最后的状态, 在执行完then或catch指定的回调函数以后,都会执行finally方法指定的回调函数, finally不接收任何参数, 这意味着没有办法知道,前面的Promise状态到底是fulfiled还是rejected,finally本质上是then方法的特例
    </script>
</body>
</html>