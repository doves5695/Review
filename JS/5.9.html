<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 手写promise
        // promise 无法捕获异步错误
        const PENDING = 'pending';
        const FULFILLED = 'fulfilled';
        const REJECTED = 'rejected';

        class MyPromise {
            #state = PENDING;
            #result = undefined;
            #handlers = [];

            constructor(executor) {
                const resolve = (data) => {
                    this.#changeState(FULFILLED, data);
                };
                const reject = (reason) => {
                    this.#changeState(REJECTED, reason);
                };
                try {
                    executor(resolve, reject);
                }   catch(err) {
                    reject(err);
                }
            }

            #changeState(state, result) {
                if (this.#state !== PENDING) return;
                    this.#state = state;
                    this.#result = result;
                    this.#run();
            }

            #run() {
                if(this.#state === PENDING) return;
                while(this.#handlers.length) {
                    const {onFulfilled, onRejected, resolve, reject} = this.#handlers.shift();
                    if(this.#state === FULFILLED) {
                        if(typeof onFulfilled === 'function') {
                            onFulfilled(this.#result);
                        }
                    } else {
                        if(typeof onRejected === 'function') {
                            onRejected(this.#result);
                        }
                    }
                }
            }

            then(onFulfilled, onRejected) {
                return new MyPromise((resolve, reject) => {
                    this.#handlers.push = ({
                        onFulfilled,
                        onRejected,
                        resolve,
                        reject
                    })
                    this.#run();
                });
            }
        }

        const p = new MyPromise((resolve,reject) => {
           setTimeout(()=> {
                resolve(666);
           },1000);
        })
        p.then(
            (res) => {
                console.log('promise 成功1', res);
            },
            (err) => {
                console.log('promise 失败1', err);
            }
        );




        // promise解决了什么问题
        // 解决了回调地狱,由于promise可以链式调用,所以使代码更加简洁


        // Promise.all和Promise.race的区别和使用场景
        // promise.all可以将多个promise实例包装成一个新的Promise实例, 同时,成功和失败的返回值不同, 成功的时候返回的是一个数组, 失败的时候返回的是第一个失败状态的值
        // promise.all传入的是数组,返回的也是数组
        // 我们需要注意,Promise.all获得的成功的数组里面的数据的顺序和Promise.all接收到的数组顺序是一致的
        // 当我们遇到发送多个请求并根据请求顺序获取和使用数据的场景, 就可以使用Promise.all来解决


        // Promise.race , 顾名思义, 它的意思就是赛跑,哪个结果获取的快,就返回哪个结果, 不管结果是成功还是失败
        // 当要做一件事,超过多长时间就不做了,可以用这个方法解决
        // Promise.race([promise1, timeOutPromise(5000)]).then(res => {})



        // 对async/await 的理解
        // async/await其实就是Generator的语法糖, 它能实现的效果都可以用then链来实现, 它是为了优化then链才开发出来的, 我们可以理解为saync用来声明一个函数是异步的, 而await用于等待一个异步方法执行完成. 语法上强制规定await只能出现在async函数中

        // async function test() {
        //     return 'hello world';
        // }
        // let result = test();
        // result.then( (res) => {
        //     console.log(res)
        // })
        // console.log(result) // 返回的是一个promise对象

        // Promise特点无等待


        // await到底在等待什么呢
        // 按照语法说明,await其实是在等待一个表达式, 这个表达式的计算结果是Promise对象或其它值(没有特殊限定)
        // 因为async函数返回一个Promise对象, 所以await可以用于等待一个async函数的返回值---这也可以说是await在等async函数, 但要清除, 它在等的是一个返回值, 注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的


        // function getSomething() {
        //     return 'something';
        // }
        // async function test() {
        //     return Promise.resolve('hello async');
        // }
        // async function Mytest() {
        //     const v1 = await getSomething();
        //     const v2 = await test();
        //     console.log(v1, v2);
        // }
        // Mytest();


        // 例: 
        // function testAsy(x) {
        //     return new Promise(resolve => {
        //         setTimeout( () => {
        //             resolve(x)
        //         },3000)
        //     })
        // }
        // async function testAwt() {
        //     let result = await testAsy('hello world');
        //     console.log(result);  // 3s后出现, 因为await后面是Promise对象,它需要等待resolve结果, 并且阻塞后面代码
        //     console.log('cuger'); // 3s后出现, 因为被阻塞了
        // }
        // testAwt();
        // console.log('cug'); // 立即出现


        


    </script>
</body>
</html>