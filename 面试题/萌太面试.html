<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* #wrapper {
            display: flex;
            width: 500px;
            height: 800px;
            border: 2px solid black;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .box1 {
            width: 200px;
            height: 200px;
            background-color: red;
        }
        .box2 {
            width: 200px;
            height: 30px;
            background-color: blue;
        } */
    </style>
</head>
<body>
    <!-- <div id="wrapper">
        <div class="box1"></div>
        <div class="box2"></div>
    </div> -->
    <script>
        // CSS的选择器有哪些, 他们的权重是如何排列的?
        // 1.行内选择器 <h1 style="width: 100px; height: 100px;"></h1>
        // 2.ID选择器
        // 3.类选择器
        // 4.元素选择器(标签选择器)
        // 5.伪类选择器
        // 6.属性选择器
        // 7.通用选择器
        // 以上的顺序就是选择器的权重排列顺序, 切记最高的是!important


        // position的值和对应作用
        // top, bottom, left, right, z-index称为五大方向属性
        // 1.static, 默认值, 不进行特殊定位, 五大方向属性对元素没有效果
        // 2.relative, 相对定位, 元素对于其自身的正常位置进行定位, 可以通过四大属性进行相对偏移, 元素仍占据原理的文章, 对其它元素的布局无影响
        // 3.absolute, 绝对定位, 元素相对于其最近的已定位的父元素(非'static')进行定位, 通过四大属性来对其控制偏移, 元素从文档流脱离, 不占据原来的位置, 其它元素也会受到影响
        // 4.fixed, 固定定位, 对于当前可视窗口进行定位, 即使页面发生了滚动, 它的位置还是对于窗口无变化, 元素从文档流脱离, 不占据原来的位置, 其它元素也会受到影响
        // 5.sticky, 粘性布局, 元素在滚动的时候根据设定的偏移值, 切换相对定位或固定定位, 通过四大属性, 来控制相对偏移, 元素在滚动到指定位置时固定, 否则按照正常文档流进行定位



        // 数组的常用方式
        // push, pop, shift, unshift, concat, slice, splice, forEach, map
        // var arr = [1,2,3,4,5];
        // var res = arr.slice(0, 3) // [1,2,3]
        // var res = arr.splice(1,3,9,10);
        // console.log(res)
        // console.log(arr)


        // vue的生命周期


        // computed和watch的区别
        // 共同之处就是都是用于观察和响应数据变化的工具
        // computed是一种根据依赖的响应式数据进行计算的属性, 而且它还具有缓存机制, 只有在依赖的响应式数据发生变化的时候, 才会重新计算, 否则会直接返回之前的计算结果
        // watch用于观察某个特定数据的变化, 并在数据变化时执行相应的回调函数, 它可以监测某个数据的变化, 包括新值和旧值, 并且可以执行任意自定义逻辑, 它更适用于异步操作, 或执行开销较大的操作, 比如发送网络请求, 调用接口等

        // computed适用于基于响应数据进行复杂计算, 而watch适用于监听特定数据的变化执行自定义操作



        // v-if和v-show的区别
        // v-if:条件渲染, 对性能影响较小, 根据表达式真假来进行判断是否渲染
        // v-show: 条件显示, 根据表达式真假来判断元素的显示或隐藏, 同样是性能影响较小
        // 注意: 当初始条件为假的时候, v-if会在首次渲染的时候跳过整个元素, 而v-show会保留, 它仅仅只是通过css来控制元素的显示和隐藏, 总结就是'v-if'适用于条件较少,改变较少的场景, 'v-show'用于频繁切换显示状态的场景



        // vue当中的数据传递方式
        // Props(父子组件通信): 通过在父组件中定义props属性，并在子组件中使用props接收父组件传递的数据。父组件可以通过绑定属性的方式将数据传递给子组件
        // 自定义事件(子组件向父组件通信): 子组件可以通过$emit方法触发一个自定义事件,并传递数据给父组件. 父组件可以通过监听子组件的自定义事件来获取传递的数据
        // 使用$refs（父组件访问子组件）：通过在子组件上设置ref属性，父组件可以通过$refs来访问子组件的实例，从而获取子组件的数据或调用子组件的方法。
        // 使用Vuex（状态管理）：Vuex是Vue.js的官方状态管理库，用于在多个组件之间共享和管理状态。组件可以通过Vuex存储数据，其他组件可以通过访问和修改Vuex中的数据来进行通信
        // Provide / Inject（祖先向后代传递数据）：祖先组件可以通过provide选项提供数据，后代组件可以通过inject选项来注入数据。这种方式允许祖先组件向所有后代组件传递数据，而无需显式地通过props传递
        // Event Bus（跨组件通信）：可以使用事件总线来进行跨组件通信。创建一个Vue实例作为事件中心，组件可以通过该实例来触发和监听事件，从而进行数据传递


        // mounted是做什么的
        // mounted是一个钩子函数, 用于在组件挂载到DOM后执行特定的操作, 它表示组件已经初始化完成，并且已经被插入到DOM中
        // 在mounted钩子函数中，可以进行以下操作
        // 1.操作dom元素利用, $ref来添加事件监听器, 修改元素样式等等
        // 2.执行异步操作
        // 3.初始化第三方库
        // 注意: mounted钩子函数只会在组件首次挂载时执行一次。如果组件被重新渲染或更新，mounted钩子函数不会再次执行。如果需要在组件更新后执行操作，可以使用updated钩子函数


        // Css当中的flex布局


        // javascript中的事件循环
        // JavaScript的事件循环机制是一种用于处理异步任务的执行模型。它使得JavaScript能够在单线程的环境中处理并发的任务
    </script>
</body>
</html>